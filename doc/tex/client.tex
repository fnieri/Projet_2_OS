
\section{Côté client}
    La partie client combine ce qui est connexion au serveur,
    envoi et réception d'un message et interface graphique, 
    réalisée en utilisant ncurses.
        \subsection{Structure du client}
        Le client, tout comme le serveur, divise son exécution
        en deux phases, l'initialisation et le \emph{main loop}.
        \subsection{Initialisation}
        Lorsque l'utilisateur lance le programme via la commande \\
        \texttt{\$ ./client <pseudo> <ip\_serveur> <port> }, le programme établit une 
        connexion avec le serveur.
        Nous créons un socket de type SOCK\_STREAM pour pouvoir communiquer entre
        plusieurs utilisateurs, et connectons l'utilisateur au serveur caracterisé 
        par l'IP et par le port introduits,
        le premier message est envoyé automatiquement et contient l'username.
        Si la connexion échoue, le programme s'arrête avec un message d'erreur.
        Le socket crée pendant la connexion sera réutilisé pour envoyer et recevoir les messages.
        \subsection{Main loop}
            L'envoi et la réception des messages s'effectue en concurrence dans le main loop,
            grâce à l'utilisation des threads et l'exclusion mutuelle avec les mutex.
            \subsubsection{Envoi des messages}
                L'envoi des messages se fait à travers une fonction auxiliaire
                \texttt{ui\_get\_input} et la fonction qui envoi les messages
                au serveur \texttt{read\_stdin}.

                \texttt{read\_stdin} appelle la fonction auxiliaire,
                qui lit l'input du client dans l'interface
                caractère par caractère, quand l'utilisateur souhaite 
                envoyer le message en appuyant sur Enter, l'input est analysé
                pour en trouver la longueur, nous prenons le timestamp et  
                construisons le \verb@struct@ \textbf{message} (cfr. section 2.1).
                
                Ensuite, la structure est envoyée au serveur, qui relaie le message contenu
                aux autres utilisateurs (cfr. section 2.3) , il est important que
                l'envoi d'un message ne soit pas perturbé par la réception d'un autre en même temps.
                Pour éviter cela, le mutex assure que l'unique traitement effectué à ce moment 
                dans le programme soit l'envoi du message.

            \subsubsection{Réception du message}
                Comme l'envoi, la réception se divise en deux partie, une relié à 
                l'interface, une relié à la vérification avec le serveur.
                
                La réception du message dans la fonction \texttt{receive\_other\_users\_messages}
                consiste à vérifier si des bytes ont été reçu sur le socket,
                si c'est bien le cas, le message est interprété par le client et est ensuite 
                affiché sur l'interface avec la fonction \texttt{ui\_print\_message} selon le schéma suivant: \\
                \begin{center}
                    \textit{HH:MM:SS [username] message} 
                \end{center}
                Comme pour l'envoi des messages, il est aussi important que
                la réception d'un \textbf{message}, et non pas la vérification de la réception de \textbf{bytes},
                soit la seule opération en cours de traitement. Si le "lock" d'un mutex
                est effectué au niveau de la réception de bytes, l'utilisateur ne pourrait jamais
                envoyer des messages.
                
        \section{Difficultés}

        Nous avons eu des problèmes avec l'envoi des chaînes de
        caractères à cause de l'omission du \verb@\0@ terminal.
        L'absence de ce dernier caractère résultait en des envois de strings
        qui n'était pas lisibles à l'arrivée puisque non délimités.
                
                

        \section{Limitations}
            Si à l'envoi d'un nouveau message, des messages anciens sont effacés du chatbox,
            il ne sera plus possible de les lire pour des limitations dues au fait que tous les messages
            devraient être stockés sur un fichier à part.
        
        \section{Exemple d'execution}
                \addimg{img/exemple.png}{width=\textwidth}{Ceci est un exemple d'execution}{exemple}